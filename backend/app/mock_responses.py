"""
Mock model responses for testing purposes.

This module provides pre-defined mock responses that can be used instead of
actual API calls to OpenRouter. This allows admins and super-admins to test
the application's behavior without incurring API costs.

The responses are designed to simulate realistic model outputs with appropriate
lengths for both standard and extended tiers.
"""

# Standard length response (approximately 500-800 tokens)
MOCK_RESPONSE_STANDARD = """I'd be happy to help you with that question. Let me provide a comprehensive answer that addresses the key points.

First, it's important to understand the context and background of this topic. The fundamental concepts involve several interconnected elements that work together to create a cohesive system. When we examine the core principles, we can see how each component plays a crucial role in the overall functionality.

Let me break this down into several key areas:

1. **Primary Considerations**: The first aspect to consider involves understanding the basic framework. This foundation is essential because it establishes the parameters within which everything else operates. Without a solid grasp of these fundamentals, it becomes difficult to appreciate the more nuanced aspects that follow.

2. **Secondary Factors**: Building upon the foundation, we need to consider the various factors that influence the outcome. These can include environmental conditions, external dependencies, and the specific requirements of your use case. Each of these elements interacts with the others in ways that can be both predictable and surprising.

3. **Practical Implementation**: When it comes to actually applying these concepts, there are several best practices to keep in mind. The most effective approach typically involves a combination of theoretical understanding and hands-on experience. It's often helpful to start with small-scale experiments before committing to larger implementations.

4. **Common Challenges**: It's worth noting that several common challenges arise in this context. These might include scalability concerns, integration difficulties, or performance optimization needs. Being aware of these potential pitfalls can help you plan more effectively and avoid unnecessary complications.

5. **Future Considerations**: Looking ahead, it's important to think about how this might evolve over time. Technology and best practices are constantly changing, so building in flexibility and maintaining adaptability will serve you well in the long run.

In conclusion, the answer to your question involves a careful balance of multiple factors. By considering each of these elements and how they relate to your specific situation, you can develop an approach that's both effective and sustainable. Remember that there's often no single "right" answer – the best solution depends on your particular needs, constraints, and goals.

I hope this helps clarify things for you. If you have any follow-up questions or would like me to elaborate on any particular aspect, please feel free to ask!"""

# Extended length response (approximately 1200-1500 tokens)
MOCK_RESPONSE_EXTENDED = """I'd be delighted to provide you with a comprehensive and detailed analysis of this topic. Let me explore this question thoroughly, examining it from multiple angles and providing you with a rich, nuanced understanding.

To begin with, it's crucial to establish a solid foundational understanding of the subject matter. The topic at hand encompasses numerous interconnected concepts, each of which contributes to the broader picture in meaningful ways. As we delve deeper into this analysis, you'll see how these various elements weave together to create a complex tapestry of ideas and practical applications.

## Historical Context and Evolution

First, let's consider the historical development of this field. Understanding where we've come from provides valuable perspective on where we are today and where we might be heading tomorrow. Over the decades, there have been significant shifts in how we approach these challenges, driven by technological advancements, changing social needs, and accumulated wisdom from countless experiments and implementations.

The early pioneers in this area faced numerous obstacles that we now take for granted as solved problems. Their innovative thinking and persistent experimentation laid the groundwork for modern approaches. It's fascinating to trace the lineage of ideas and see how concepts that were once revolutionary have become standard practice.

## Core Principles and Fundamental Concepts

Now, let's examine the core principles that underpin this entire domain. These fundamentals serve as the bedrock upon which all subsequent understanding is built:

1. **The First Principle**: This foundational concept relates to the basic mechanisms at play. It's essential to understand not just what happens, but why it happens. The underlying logic here involves a series of cause-and-effect relationships that, once understood, make everything else much clearer. Think of this as the master key that unlocks deeper comprehension.

2. **The Second Principle**: Building upon the first, this principle addresses the dynamic interactions between different components. It's not enough to understand each piece in isolation – we must also grasp how they influence one another. This creates a system of feedback loops and emergent properties that can produce outcomes greater than the sum of their parts.

3. **The Third Principle**: This relates to scalability and sustainability. Solutions that work well at small scales may face significant challenges when expanded. Understanding the constraints and opportunities at different scales is crucial for effective planning and implementation.

## Practical Applications and Real-World Scenarios

Moving from theory to practice, let's explore how these concepts manifest in real-world situations. I'll walk you through several scenarios that illustrate the key points:

**Scenario One**: Imagine you're starting from scratch with a new project. Your first steps would involve careful assessment of your specific requirements, available resources, and constraints. This initial planning phase is critical – decisions made here will have rippling effects throughout the entire lifecycle of your project.

You'd want to consider factors such as timeline, budget, technical capabilities of your team, and the specific goals you're trying to achieve. Each of these factors will influence your approach and the trade-offs you'll need to make along the way.

**Scenario Two**: Now consider a situation where you're working with an existing system that needs to be improved or modified. This presents a different set of challenges, as you need to balance the desire for improvement with the risks associated with changing a working system. The "if it ain't broke, don't fix it" philosophy must be weighed against the potential benefits of modernization and optimization.

In this context, incremental changes often prove more successful than wholesale rewrites. By making small, measured improvements and carefully monitoring their effects, you can achieve significant overall enhancement while minimizing risk.

**Scenario Three**: Finally, let's think about long-term maintenance and evolution. Systems don't exist in static environments – they must adapt to changing requirements, new technologies, and shifting user needs. Building in flexibility from the start can save enormous amounts of time and effort down the line.

## Advanced Considerations and Edge Cases

As we delve into more sophisticated territory, several advanced topics deserve attention:

- **Performance Optimization**: While getting something working is the first priority, ensuring it works efficiently is equally important for long-term success. This involves understanding bottlenecks, profiling performance, and making informed decisions about where to invest optimization efforts.

- **Security and Reliability**: In today's environment, these concerns cannot be afterthoughts. Building robust, secure systems requires thinking about potential failure modes, attack vectors, and recovery strategies from the very beginning.

- **User Experience**: Technical excellence means little if the end result doesn't serve users well. Keeping the human element at the center of your design process ensures that technical decisions align with actual needs.

## Common Pitfalls and How to Avoid Them

Through extensive experience, several common mistakes have emerged that trip up even experienced practitioners:

1. **Over-engineering**: The temptation to build overly complex solutions that handle every conceivable edge case can lead to systems that are difficult to maintain and understand. Often, simpler approaches prove more robust in practice.

2. **Under-planning**: Conversely, diving into implementation without adequate planning can result in having to backtrack and redo work. Finding the right balance between planning and action is an art in itself.

3. **Ignoring feedback**: Whether from users, monitoring systems, or team members, valuable feedback can easily be overlooked in the rush to meet deadlines. Building in regular feedback cycles and actually acting on what you learn is crucial.

## Looking Forward: Future Trends and Developments

As we look to the future, several emerging trends are likely to shape how we approach these challenges:

The pace of technological change continues to accelerate, bringing both opportunities and challenges. New tools and frameworks appear regularly, each promising to solve longstanding problems in novel ways. While it's important to stay informed about these developments, it's equally important to maintain a healthy skepticism and carefully evaluate whether new approaches truly offer advantages for your specific situation.

Additionally, there's a growing emphasis on sustainability, both in terms of environmental impact and long-term maintainability. Solutions that seemed acceptable in the past may no longer meet current standards for efficiency and resource usage.

## Synthesis and Recommendations

Bringing all of this together, here are my key recommendations:

- Start with a solid understanding of fundamentals before moving to advanced topics
- Consider your specific context carefully – what works for others may not work for you
- Build in flexibility and adaptability from the start
- Don't underestimate the importance of good documentation and knowledge sharing
- Regularly review and refine your approaches based on results and feedback
- Stay informed about new developments, but don't chase every shiny new tool
- Remember that the goal is to solve real problems, not to use the most cutting-edge technology

## Conclusion

In wrapping up this comprehensive exploration, I hope I've provided you with a thorough understanding that addresses not just the surface-level aspects of your question, but also the deeper implications and contextual factors that influence the answer. The topic we've discussed is rich with nuance and practical considerations that can't be captured in a simple sound bite.

The most important takeaway is that thoughtful, informed decision-making requires considering multiple perspectives and understanding the trade-offs involved in different approaches. There's rarely a single "correct" answer that applies universally – instead, the best solution emerges from careful analysis of your specific situation, constraints, and goals.

I encourage you to take these concepts and apply them thoughtfully to your own context. Experiment, measure results, and continuously refine your approach based on what you learn. If you have any follow-up questions or would like me to dive deeper into any particular aspect of what we've discussed, I'm here to help. Thank you for this engaging question!"""


def get_mock_response(tier: str = "standard") -> str:
    """
    Get a mock response based on the requested tier.
    
    Args:
        tier: Response tier ('standard', 'extended', or 'brief')
        
    Returns:
        Mock response string appropriate for the tier
    """
    if tier == "extended":
        return MOCK_RESPONSE_EXTENDED
    elif tier == "brief":
        # For brief tier, return a truncated version of the standard response
        return MOCK_RESPONSE_STANDARD.split('\n\n')[0] + "\n\nI hope this brief overview helps!"
    else:
        # Default to standard
        return MOCK_RESPONSE_STANDARD


def stream_mock_response(tier: str = "standard", chunk_size: int = 50):
    """
    Generator that yields mock response in chunks to simulate streaming.
    
    Args:
        tier: Response tier ('standard', 'extended', or 'brief')
        chunk_size: Number of characters per chunk (default: 50)
        
    Yields:
        String chunks of the mock response
    """
    response = get_mock_response(tier)
    
    # Split into chunks and yield
    for i in range(0, len(response), chunk_size):
        chunk = response[i:i + chunk_size]
        yield chunk

