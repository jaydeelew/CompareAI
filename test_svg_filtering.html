<!DOCTYPE html>
<html lang="en">

<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>SVG Filtering Test</title>
    <script src="https://unpkg.com/react@18/umd/react.development.js"></script>
    <script src="https://unpkg.com/react-dom@18/umd/react-dom.development.js"></script>
    <script src="https://unpkg.com/katex@0.16.8/dist/katex.min.js"></script>
    <link rel="stylesheet" href="https://unpkg.com/katex@0.16.8/dist/katex.min.css">
</head>

<body>
    <div id="root"></div>

    <script>
        const { useState } = React;

        const LatexRenderer = ({ children, className = '' }) => {
            const renderLatex = (text) => {
                try {
                    let processedText = text;

                    // Preprocess: Clean up SVG path data and other unwanted content
                    // Remove specific SVG path data patterns that appear in AI responses
                    processedText = processedText.replace(/c-2\.7,0,-7\.17,-2\.7,-13\.5,-8c-5\.8,-5\.3,-9\.5,-10,-9\.5,-14[^"]*H400000v40H845\.2724[^"]*M834 80h400000v40h-400000z/g, '');

                    // Remove other common SVG path patterns
                    processedText = processedText.replace(/[a-zA-Z]\s*[0-9.-]+(?:[,\s][0-9.-]+){20,}/g, '');

                    // Remove SVG path data patterns (long sequences of numbers, letters, and special chars)
                    processedText = processedText.replace(/[a-zA-Z0-9\s,.-]{50,}/g, (match) => {
                        // Check if this looks like SVG path data (contains many numbers, letters, commas, periods)
                        const hasManyNumbers = (match.match(/\d/g) || []).length > 10;
                        const hasManyCommas = (match.match(/,/g) || []).length > 5;
                        const hasManyLetters = (match.match(/[a-zA-Z]/g) || []).length > 5;

                        if (hasManyNumbers && hasManyCommas && hasManyLetters) {
                            return ''; // Remove SVG path data
                        }
                        return match; // Keep other long sequences
                    });

                    // Remove standalone SVG path elements that might be mixed in
                    processedText = processedText.replace(/<path[^>]*d="[^"]*"[^>]*\/>/g, '');
                    processedText = processedText.replace(/<svg[^>]*>.*?<\/svg>/gs, '');

                    // Remove any remaining SVG-related attributes or elements
                    processedText = processedText.replace(/<[^>]*(?:viewBox|xmlns|stroke|fill)[^>]*>/g, '');

                    // Clean up any remaining malformed HTML that might contain SVG data
                    processedText = processedText.replace(/<[^>]*style="[^"]*"[^>]*>/g, (match) => {
                        // If it contains SVG-related styles, remove the whole element
                        if (match.includes('svg') || match.includes('path') || match.includes('viewBox')) {
                            return '';
                        }
                        return match;
                    });

                    // Clean up any remaining mixed content that has SVG path data mixed with text
                    processedText = processedText.replace(/([^>])\s*[a-zA-Z0-9\s,.-]{30,}\s*([^<])/g, (match, before, after) => {
                        // Check if the middle part looks like SVG path data
                        const middle = match.slice(before.length, match.length - after.length);
                        const hasManyNumbers = (middle.match(/\d/g) || []).length > 5;
                        const hasManyCommas = (middle.match(/,/g) || []).length > 3;

                        if (hasManyNumbers && hasManyCommas) {
                            return before + ' ' + after; // Remove the SVG data, keep the surrounding text
                        }
                        return match;
                    });

                    return processedText;
                } catch (error) {
                    console.warn('Error processing LaTeX:', error);
                    return text;
                }
            };

            const processedContent = renderLatex(children);

            return React.createElement('div', {
                className: `latex-content ${className}`,
                dangerouslySetInnerHTML: { __html: processedContent },
                style: {
                    whiteSpace: 'normal',
                    fontFamily: 'inherit',
                    lineHeight: 'inherit',
                    wordWrap: 'break-word',
                    overflowWrap: 'break-word',
                    maxWidth: '100%',
                    overflow: 'hidden'
                }
            });
        };

        const TestApp = () => {
            const [testText, setTestText] = useState(`A square root is a mathematical operation that finds a number which, when multiplied by itself, gives the original number.

c-2.7,0,-7.17,-2.7,-13.5,-8c-5.8,-5.3,-9.5,-10,-9.5,-14 c0,-2,0.3,-3.3,1,-4c1.3,-2.7,23.83,-20.7,67.5,-54 c44.2,-33.3,65.8,-50.3,66.5,-51c1.3,-1.3,3,-2,5,-204.7,0,8.7,3.3,12,10 s173,378,173,378c0.7,0,35.3,-71,104,-213c68.7,-142,137.5,-285,206.5,-429 c69,-144,104.5,-217.7,106.5,-221 c0,-0.5,3,-9.3,12,-14,20,-14 H400000v40H845.2724 s-225.272,467,-225.272,467s-235,486,-235,486c-2.7,4.7,-9,7,-19,7 c-6,0,-10,-1,-12,-3s-194,-422,-194,-422s-65,47,-65,47z M834 80h400000v40h-400000z

Examples:
2. The square root of 16 is 4 because (4 x 4 = 16).

Important Points:
- The square root of zero is zero.
- The square root of a number a is a value that, when multiplied by itself, gives the original number a. In other words, b is the square root of a if: b x b = a
- Notation: The square root of a is denoted as: √a
- Examples: √9 is 3 because (3 x 3 = 9). and √16 = 4
- Negative numbers do not have real square roots because no real number multiplied by itself gives a negative result. However, they do have imaginary square roots.`);

            return React.createElement('div', { style: { padding: '20px', fontFamily: 'Arial, sans-serif' } }, [
                React.createElement('h1', { key: 'title' }, 'SVG Filtering Test'),
                React.createElement('h2', { key: 'before' }, 'Before Filtering:'),
                React.createElement('pre', {
                    key: 'before-text',
                    style: {
                        background: '#f5f5f5',
                        padding: '10px',
                        borderRadius: '5px',
                        whiteSpace: 'pre-wrap',
                        fontSize: '12px'
                    }
                }, testText),
                React.createElement('h2', { key: 'after' }, 'After Filtering:'),
                React.createElement('div', {
                    key: 'after-rendered',
                    style: {
                        border: '1px solid #ccc',
                        padding: '10px',
                        borderRadius: '5px',
                        background: 'white'
                    }
                }, React.createElement(LatexRenderer, { children: testText }))
            ]);
        };

        ReactDOM.render(React.createElement(TestApp), document.getElementById('root'));
    </script>
</body>

</html>